/*        Hierarchy Builder: algebraic hierarchies made easy
    This software is released under the terms of the MIT license              */


% This file contains additions to coq-elpi's library as well as
% some HB specific utilities (eg to handle w-params stuff)

shorten coq.{ term->gref, subst-fun, safe-dest-app, mk-app, mk-eta, subst-prod }.

%%%%%%%%% Elpi Utils %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This code could be moved in Elpi's standard library

% printing the local mixin context
pred print-ctx.
print-ctx :- declare_constraint print-ctx [].
constraint print-ctx mixin-src {
  rule \ (G ?- print-ctx) | (coq.say "The context is:" G).
}

% TODO: pred toposort i:(A -> A -> prop), i:list A, o:list A.
%       pred edge? i:int, i:int.
%       toposort edge? [1,2,3,4] TopoList
pred topovisit i: list (pair A A), i: A,      i: list A, i: list A, o: list A, o: list A.
topovisit _ X VS PS VS PS :- std.mem PS X, !.
topovisit _ X VS _ _ _ :- std.mem VS X, !, halt "cycle detected.".
topovisit ES X VS PS VS' [X|PS'] :-
  toporec ES {std.map {std.filter ES (e\ fst e X)} snd} [X|VS] PS VS' PS'.
pred toporec   i: list (pair A A), i: list A, i: list A, i: list A, o: list A, o: list A.
toporec _ [] VS PS VS PS.
toporec ES [X|XS] VS PS VS'' PS'' :-
  topovisit ES X VS PS VS' PS', toporec ES XS VS' PS' VS'' PS''.
pred toposort i: list (pair A A), i: list A, o: list A.
toposort ES XS XS'' :-
  toporec ES XS [] [] _ XS',
  std.filter XS' (std.mem XS) XS''.

pred bubblesort i:list A, i:(A -> A -> prop), o:list A.
bubblesort [] _ [] :- !.
bubblesort [X] _ [X] :- !.
bubblesort [X,Y|TL] Rel [X|Rest1] :- Rel X Y, !, bubblesort [Y|TL] Rel Rest1.
bubblesort [X,Y|TL] Rel [Y|Rest1] :- bubblesort [X|TL] Rel Rest1.

pred list-diff i:list A, i:list A, o:list A.
list-diff X [] X.
list-diff L [D|DS] R :-
  std.filter L (x\ not(x = D)) L1,
  list-diff L1 DS R.

pred list-eq-set i:list A, i:list A.
list-eq-set L1 L2 :- list-diff L1 L2 [], list-diff L2 L1 [].

pred under.do! i:((A -> Prop) -> A -> prop), i:list prop.
under.do! Then LP :- Then (_\ std.do! LP) _.

pred map-triple i:(A -> A1 -> prop), i:(B -> B1 -> prop), i:(C -> C1 -> prop), i:triple A B C, o:triple A1 B1 C1.
map-triple F G H (triple X Y Z) (triple X1 Y1 Z1) :- F X X1, G Y Y1, H Z Z1.

pred triple_1 i:triple A B C, o:A.
triple_1 (triple A _ _) A.

pred triple_2 i:triple A B C, o:B.
triple_2 (triple _ B _) B.

pred target-gref i:term, o:gref.
target-gref T GR :- whd1 T T1, !, target-gref T1 GR.
target-gref (prod N Src Tgt) GR :- !, @pi-decl N Src x\ target-gref (Tgt x) GR.
target-gref End GR :- term->gref End GR.

% TODO: replace with std.map-filter when coq-elpi > 1.9.2
pred map-filter i:list A, i:(A -> B -> prop), o:list B.
map-filter [] _ [].
map-filter [X|XS] F [Y|YS] :- F X Y, !, map-filter XS F YS.
map-filter [_|XS] F YS :- map-filter XS F YS.

pred head-gref-under-prods i:term, o:gref.
head-gref-under-prods (prod N T Body) Hd :-
  @pi-decl N T x\ head-gref-under-prods (Body x) Hd.
head-gref-under-prods T Hd :- whd1 T T', head-gref-under-prods T' Hd.
head-gref-under-prods T Hd :- safe-dest-app T (global Hd) _.

%%%%% HB Utils %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% HACK: move to coq-elpi proper, remove when coq-elpi > 1.9.2
type attmap attribute-type.

% runs P in a context where Coq #[attributes] are parsed
pred with-attributes i:prop.
with-attributes P :-
  attributes A,

% HACK: move to coq-elpi proper, remove when coq-elpi > 1.9.2
(pi S L AS Prefix R R1 Map PS\ 
  parse-attributes.aux [attribute S (node L)|AS] Prefix R :-
    if (Prefix = "") (PS = S) (PS is Prefix ^ "." ^ S), supported-attribute (att PS attmap), !,
    parse-attributes.aux AS Prefix R1,
    (pi x\ supported-attribute (att x string) :- !) => parse-attributes.aux L "" Map,
    std.append R1 [get-option PS Map] R
) =>

  coq.parse-attributes A [
    att "verbose" bool,
    att "mathcomp" bool,
    att "mathcomp.axiom" string,
    att "infer" attmap,
    att "key" string,
    att "arg_sort" bool,
  ] Opts, !,
  Opts => P.

% TODO: move to coq-elpi proper / move to coq.pp in coq-elpi >= 1.9
pred coq.indt-decl->string i:indt-decl, o:string.
coq.indt-decl->string (parameter ID _ Ty D) S :-
  coq.id->name ID Name,
  (@pi-decl Name Ty x\ coq.indt-decl->string (D x) S1),
  S is "Parameter" ^ ID ^ " : " ^ {coq.term->string Ty} ^ "\n" ^ S1.
coq.indt-decl->string (inductive _ _ _ _) "NYI".
coq.indt-decl->string (record ID Ty KID RD) S :-
  coq.record-decl->string RD S1,
  S is ID ^ " : " ^ {coq.term->string Ty} ^ " := " ^ KID ^ " {\n" ^ S1 ^ "}".
pred coq.record-decl->string i:record-decl, o:string.
coq.record-decl->string end-record "".
coq.record-decl->string (field _ ID Ty D) S :-
  coq.id->name ID Name,
  (@pi-decl Name Ty x\ coq.record-decl->string (D x) S1),
  S is "  " ^ ID ^ " : " ^ {coq.term->string Ty} ^ ";\n" ^ S1.
pred coq.ground-indt-decl? i:indt-decl.
coq.ground-indt-decl? (parameter ID _ Ty D) :-
  ground_term Ty,
  coq.id->name ID Name, (@pi-decl Name Ty x\ coq.ground-indt-decl? (D x)).
coq.ground-indt-decl? (inductive _ _ _ _).
coq.ground-indt-decl? (record _ Ty _ RD) :-
  ground_term Ty,
  coq.ground-record-decl? RD.
pred coq.ground-record-decl? i:record-decl.
coq.ground-record-decl? end-record.
coq.ground-record-decl? (field _ ID Ty D) :-
  ground_term Ty,
  coq.id->name ID Name, (@pi-decl Name Ty x\ coq.ground-record-decl? (D x)).

% TODO: remove when coq-elpi > 1.9.3
pred copy-indt-decl i:indt-decl, o:indt-decl.
copy-indt-decl (parameter ID I Ty D) (parameter ID I Ty1 D1) :-
  copy Ty Ty1,
  @pi-parameter ID Ty1 x\ copy-indt-decl (D x) (D1 x).
copy-indt-decl (inductive ID CO A D) (inductive ID CO A1 D1) :-
  copy-arity A A1,
  coq.id->name ID N, coq.arity->term A1 T, @pi-decl N T i\ std.map (D i) copy-constructor (D1 i).
  % @pi-inductive ID A1 i\ std.map (D i) copy-constructor (D1 i). % requires Coq-Elpi 1.9.x
copy-indt-decl (record ID T IDK F) (record ID T1 IDK F1) :-
  copy T T1,
  copy-fields F F1.
pred copy-fields i:record-decl, o:record-decl.
copy-fields end-record end-record.
copy-fields (field Att ID T F) (field Att ID T1 F1) :-
  copy T T1,
  @pi-parameter ID T1 x\ copy-fields (F x) (F1 x).
pred copy-constructor i:indc-decl, o:indc-decl.
copy-constructor (constructor ID A) (constructor ID A1) :- copy-arity A A1.

% TODO: move to coq-elpi proper
pred coq.gref.list->set i:list mixinname, o:coq.gref.set.
coq.gref.list->set L S :-
  std.fold L {coq.gref.set.empty} coq.gref.set.add S.

pred if-verbose i:prop.
if-verbose P :- get-option "verbose" tt, !, P.
if-verbose _.

pred if-arg-sort i:prop.
if-arg-sort P :- get-option "arg_sort" tt, !, P.
if-arg-sort _.

pred if-MC-compat i:(option gref -> prop).
if-MC-compat P :- get-option "mathcomp" tt, !, P none.
if-MC-compat P :- get-option "mathcomp.axiom" S, !,
  std.assert! (coq.locate S GR) "The name passed to the mathcomp.axiom attribute does not exist",
  P (some GR).
if-MC-compat _.

% TODO: Should this only be used for gref that are factories? (and check in the first/second branch so?)
% Should we make this an HO predicate, eg "located->gref S L is-factory? GR"
% TODO: rename since this is HB specific and is expected to return a factory
pred located->gref i:string, i:list located, o:gref.
located->gref _ [loc-gref GR|_] GR.
located->gref _ [loc-abbreviation Abbrev|_] GR :- phant-abbrev GR _ Abbrev, !.
located->gref S [loc-abbreviation _|_] _ :- coq.error S "is an abbreviation out of the control of HB".
located->gref S [loc-modpath _|_] _ :- coq.error S "should be a factory, but is a module".
located->gref S [loc-modtypath _|_] _ :- coq.error S "should be a factory, but is a module type".
located->gref S [] _ :- coq.error "Could not locate name" S.

% TODO: generalize/rename when we support parameters
pred argument->gref i:argument, o:gref.
argument->gref (str S) GR :- located->gref S {coq.locate-all S} GR.
argument->gref X _ :- coq.error "Argument" X "is expected to be a string".

pred argument->term i:argument, o:term.
argument->term (str S) (global GR) :- !, argument->gref (str S) GR.
argument->term (trm T) T1 :- !, std.assert-ok! (coq.elaborate-skeleton T _ T1) "not well typed term".
argument->term X _ :- coq.error "Argument" X " is expected to be a term or a string".

pred argument->ty i:argument, o:term.
argument->ty (str S) T1 :- !, argument->gref (str S) GR, std.assert-ok! (coq.elaborate-ty-skeleton (global GR) _ T1) "global reference is not a type".
argument->ty (trm T) T1 :- !, std.assert-ok! (coq.elaborate-ty-skeleton T _ T1) "not well typed type".
argument->ty X _ :- coq.error "Argument" X " is expected to be a type or a string".

pred builder->string i:builder, o:string.
builder->string (builder _ _ _ B) S :- coq.term->string (global B) S.

pred nice-gref->string i:gref, o:string.
nice-gref->string X Mod :-
  coq.gref->path X Path,
  std.rev Path [_,Mod|_], !.
nice-gref->string X S :-
  coq.term->string (global X) S.

pred gref->modname i:mixinname, o:id.
gref->modname GR ModName :-
  coq.gref->path GR Path,
  if (std.rev Path [_,ModName|_]) true (coq.error "No enclosing module for " GR).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function to predicate generic constructions %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred mk-nil o:any.
mk-nil [].
pred mk0 i:any, o:any.
mk0 F R :- constant R F [].
pred mk1 i:any, i:any, o:any.
mk1 F X1 R :- constant R F [X1].
pred mk2 i:any, i:any, i:any, o:any.
mk2 F X1 X2 R :- constant R F [X1, X2].
pred mk3 i:any, i:any, i:any, i:any, o:any.
mk3 F X1 X2 X3 R :- constant R F [X1, X2, X3].
pred mk4 i:any, i:any, i:any, i:any, i:any, o:any.
mk4 F X1 X2 X3 X4 R :- constant R F [X1, X2, X3,X4].

pred mk-fun i:name, i:term, i:(term -> term), o:term.
mk-fun N Ty Body (fun N Ty Body).

% generic argument to pass to w-params
pred ignore i:name, i:term, i:(term -> A), o:A.
ignore _ _ F X :- (pi x y\ F x = F y), X = F (sort prop).

% combining body and type
pred mk-fun-prod i:name, i:term, o:(term -> pair term term), o:pair term term.
mk-fun-prod N Ty (x\ pr (Body x) (Type x)) (pr (fun N Ty Body) (prod N Ty Type)).

pred mk-parameter i:implicit_kind, i:name, i:term, i:(term -> indt-decl), o:indt-decl.
mk-parameter IK Name X F Decl :- !, Decl = parameter {coq.name->id Name} IK X F.

pred params->holes i:list-w-params A, o:list term.
params->holes (w-params.nil _ _ _) [].
params->holes (w-params.cons _ _ F) [_|PS] :- pi x\ params->holes (F x) PS.

pred fresh-type o:term.
fresh-type Ty :-
  Ty = {{Type}},
  std.assert-ok! (coq.typecheck-ty Ty _) "impossible".

%%%%%%%%%%%%%%%%%%%%%%
% w-params interface %
%%%%%%%%%%%%%%%%%%%%%%

pred apply-w-params i:w-params A, i:list term, i:term, o:A.
apply-w-params (w-params.cons _ _ PL) [P|PS] T R :- !, apply-w-params (PL P) PS T R.
apply-w-params (w-params.nil _ _ L) [] T R :- !, R = L T.
apply-w-params _ _ _ _ :- coq.error "apply-w-params".

pred w-params.nparams i:w-params A, o:int.
w-params.nparams (w-params.cons _ _ F) N :- pi x\ w-params.nparams (F x) M, N is M + 1.
w-params.nparams (w-params.nil _ _ _) 0.

% [w-params.fold AwP Cons Nil Out] states that Out has shape
%   Cons `x_1` T_1 p_1 \ .. \ Nil [p_1 .. p_n] `T` Ty F
%   where AwP = w-params.cons `x_1` T_1 p_1 \ ... \ w-params.nil `T` Ty F
pred w-params.fold i:w-params A, i:(name -> term -> (term -> B) -> B -> prop),
   i:(list term -> name -> term -> (term -> A) -> B -> prop), o:B.
w-params.fold L Cons Nil Out :- w-params.fold.params L Cons Nil [] Out.

pred w-params.fold.params i:w-params A,
   i:(name -> term -> (term -> B) -> B -> prop),
   i:(list term -> name -> term -> (term -> A) -> B -> prop),
   i:list term, % accumulator
   o:B.
w-params.fold.params (w-params.cons N PTy F) Cons Nil RevPs Out :- !, std.do! [
  (@pi-decl N PTy p\ w-params.fold.params (F p) Cons Nil [p|RevPs] (Body p)),
  Cons N PTy Body Out].
w-params.fold.params (w-params.nil NT TTy F) _ Nil RevParams Out :- !,
  std.rev RevParams Params, !, Nil Params NT TTy F Out.

% [w-params.then AwP Cons Nil Out] states that Out has shape
%   Cons `x_1` T_1 p_1 \ .. \ Nil [p_1 .. p_n] `T` Ty t \ Body
%   where Pred [p_1 .. p_n] T Body
%   and AwP = w-params.cons `x_1` T_1 p_1 \ ... \ w-params.nil `T` Ty F
pred w-params.then i:w-params A,
   i:(name -> term -> (term -> C) -> C -> prop),
   i:(name -> term -> (term -> B) -> C -> prop),
   i:(list term -> term -> A -> B -> prop),
   o:C.
w-params.then L Cons Nil Pred Out :-
  w-params.fold L Cons (ps\ n\ ty\ f\ out\ sigma Body\
    (@pi-decl n ty t\ Pred ps t (f t) (Body t)),
    Nil n ty Body out) Out.

pred w-params.map i:w-params A, i:(list term -> term -> A -> B -> prop), o:w-params B.
w-params.map AL F BL :- w-params.then AL (mk3 w-params.cons) (mk3 w-params.nil) F BL.

% on the fly abstraction
pred bind-nil i:name, i:term, i:term, i:A, o:w-params A.
bind-nil N T X V (w-params.nil N T A) :- V = A X.

pred bind-cons i:name, i:term, i:term, i:w-params A, o:w-params A.
bind-cons N T X V (w-params.cons N T A) :- V = A X.

% Specific to list-w-params
pred list-w-params_list i:list-w-params A, o:list A.
list-w-params_list AwP R :- w-params.then AwP ignore ignore
   (p\ t\ x\ std.map x triple_1) R.

pred list-w-params.append i:list-w-params A, i:list-w-params A, o:list-w-params A.
list-w-params.append (w-params.nil N T ML1) (w-params.nil N T ML2) (w-params.nil N T ML) :-
  pi x\ std.append (ML1 x) (ML2 x) (ML x).
list-w-params.append (w-params.cons N Ty ML1) (w-params.cons N Ty ML2) (w-params.cons N Ty ML) :-
  pi x\ list-w-params.append (ML1 x) (ML2 x) (ML x).

pred list-w-params.rcons i:list-w-params A, i:(list term -> term -> w-args A -> prop), o:list-w-params A.
list-w-params.rcons LwP F R :- list-w-params.rcons.aux LwP F [] R.
list-w-params.rcons.aux (w-params.nil N T ML1) F Acc (w-params.nil N T ML2) :-
  pi x\ sigma Last\ F {std.rev Acc} x Last, std.append (ML1 x) [Last] (ML2 x).
list-w-params.rcons.aux (w-params.cons N Ty ML1) F Acc (w-params.cons N Ty ML2) :-
  pi x\ list-w-params.rcons.aux (ML1 x) F [x|Acc] (ML2 x).

pred list-w-params.flatten-map
  i:list-w-params A,
  i:(A -> list-w-params B -> prop),
  o:list-w-params B.
list-w-params.flatten-map (w-params.cons N T L) F (w-params.cons N T L1) :-
  @pi-decl N T p\
    list-w-params.flatten-map (L p) F (L1 p).
list-w-params.flatten-map (w-params.nil N TTy L) F (w-params.nil N TTy L1) :-
  @pi-decl N TTy t\
    list-w-params.flatten-map.aux (L t) F (L1 t).

pred list-w-params.flatten-map.aux
  i:list (w-args A), i:(A -> list-w-params B -> prop), o:list (w-args B).
list-w-params.flatten-map.aux [] _ [].
list-w-params.flatten-map.aux [triple M Ps T|L] F Res1 :-
  F M MwP,
  apply-w-params MwP Ps T ML,
  list-w-params.flatten-map.aux L F Res,
  std.append ML Res Res1.

% [build-list-w-params TheParams TheType Factorties ListWParams]
% Params is a list of pairs (section variable, its type).
% ListWParams has as many w-params.cons as TheParams and the terms
% in Factories are abstracted wrt the first component of TheParams.
pred build-list-w-params i:list (triple id term term), i:term, i:list (w-args A), o: list-w-params A.
build-list-w-params [triple ID P Pty|PS] TheType Factories (w-params.cons Name Pty1 R) :- std.do! [
  coq.id->name ID Name,
  copy Pty Pty1,
  (pi p\ (copy P p :- !) => build-list-w-params PS TheType Factories (R p)),
].
build-list-w-params [] TheType Factories (w-params.nil `TheType` TT R) :- std.do! [
  std.assert-ok! (coq.typecheck TheType TT) "BUG: TheType does not typecheck",
  (pi t\ (copy TheType t :- !) =>
         std.map Factories (map-triple (=) (x\ std.map x copy) copy) (R t)),
].

pred distribute-w-params i:list-w-params A, o:list (one-w-params A).
distribute-w-params (w-params.cons N T F) L :-
  pi x\ distribute-w-params (F x) (L1 x), std.map (L1 x) (bind-cons N T x) L.
distribute-w-params (w-params.nil N T F) L :-
  pi x\ std.map (F x) (bind-nil N T x) L.

% Specific to one-w-params
pred w-params_1 i:one-w-params A, o:A.
w-params_1 X Y :- w-params.then X ignore ignore (p\ t\ triple_1) Y.

% [abstract-indt-decl Section I AbsI] abstracts I over the Section variables
% which becomes parameter nodes if the indt-decl type
pred abstract-indt-decl i:list constant, i:indt-decl, o:indt-decl.
abstract-indt-decl [] X X1 :- copy-indt-decl X X1.
abstract-indt-decl [C|CS] X (parameter ID explicit Ty1 X1) :-
  coq.gref->string (const C) ID,
  coq.env.typeof (const C) Ty,
  copy Ty Ty1,
  @pi-parameter ID Ty x\
    (copy (global (const C)) x :- !) =>
    abstract-indt-decl CS X (X1 x).

% [copy-clauses-for-unfold CS CL] generates clauses for the copy predicate
% to unfold all constants in CS
pred copy-clauses-for-unfold i:list constant, o:list prop.
copy-clauses-for-unfold [] [].
copy-clauses-for-unfold [C|CS] [ClauseApp,Clause|L] :-
  coq.env.const C (some B) _,
  ClauseApp = (pi B1 Args Args1 B2 Args2 R\
    copy (app[global (const C)|Args]) R :- !,
      copy B B1,
      std.map Args copy Args1,
      hd-beta B1 Args1 B2 Args2,
      unwind B2 Args2 R),
  Clause = (pi B1\
    copy (global (const C)) B1 :- !, copy B B1),
  copy-clauses-for-unfold CS L.

pred purge-id i:term, o:term.
purge-id T T1 :-
  (pi fresh t v\ copy {{lib:@hb.id lp:t lp:v}} fresh :- !) => copy T T1.


%TODO: move all non HB related stuff to coq-elpi-extra.elpi
