/*        Hierarchy Builder: algebraic hierarchies made easy
    This software is released under the terms of the MIT license              */

%%%%%%% Naming converntions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% - under-foobar.do! Arg [ Code ]
%   enriches the context with foobar, the runs std.do! [ Code ]
% - under-foobar.then Arg F Out
%   enriches the context with foobar, the runs F Out, as a consequence
%   the spilling expression {under-foobar.then Arg F} can be used
% - foo_bar
%   projection from foo to its field bar
% - foo->bar
%   conversion from type foo to type bar (it can be arbitrarily complex)
% - get-foobar
%   reads foobar from the Coq world
% - findall-foobar
%   reads foobar from hb.db, the output is sorted whenever it makes sense
% - main-foobar
%   main entry point for a user facing (or almost user facing) command foobar
% - declare-foobar
%   predicate adding to the Coq ennvironment a foobar
% - postulate-foobar
%   predicate assuming a foobar (declaring a Coq section variable)
% - TheType, TheClass, TheFoobar
%   the thing the current code is working on, eg the type of the structure
%   begin defined
% - FooAlias
%   see phant-abbrev, used to talk about the non canonical name of Foo

%%%%%%%%% Elpi Utils %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This code could be moved in Elpi's standard library

% TODO: pred toposort i:(A -> A -> prop), i:list A, o:list A.
%       pred edge? i:int, i:int.
%       toposort edge? [1,2,3,4] TopoList
pred topovisit i: list (pair A A), i: A,      i: list A, i: list A, o: list A, o: list A.
topovisit _ X VS PS VS PS :- std.mem PS X, !.
topovisit _ X VS _ _ _ :- std.mem VS X, !, halt "cycle detected.".
topovisit ES X VS PS VS' [X|PS'] :-
  toporec ES {std.map {std.filter ES (e\ fst e X)} snd} [X|VS] PS VS' PS'.
pred toporec   i: list (pair A A), i: list A, i: list A, i: list A, o: list A, o: list A.
toporec _ [] VS PS VS PS.
toporec ES [X|XS] VS PS VS'' PS'' :-
  topovisit ES X VS PS VS' PS', toporec ES XS VS' PS' VS'' PS''.
pred toposort i: list (pair A A), i: list A, o: list A.
toposort ES XS XS'' :-
  toporec ES XS [] [] _ XS',
  std.filter XS' (std.mem XS) XS''.

pred bubblesort i:list A, i:(A -> A -> prop), o:list A.
bubblesort [] _ [] :- !.
bubblesort [X] _ [X] :- !.
bubblesort [X,Y|TL] Rel [X|Rest1] :- Rel X Y, !, bubblesort [Y|TL] Rel Rest1.
bubblesort [X,Y|TL] Rel [Y|Rest1] :- bubblesort [X|TL] Rel Rest1.

pred list-diff i:list A, i:list A, o:list A.
list-diff X [] X.
list-diff L [D|DS] R :-
  std.filter L (x\ not(x = D)) L1,
  list-diff L1 DS R.

pred list-eq-set i:list A, i:list A.
list-eq-set L1 L2 :- list-diff L1 L2 [], list-diff L2 L1 [].

pred mk-n-holes i:int, o:list A.
mk-n-holes 0 [] :- !.
mk-n-holes N [HOLE_|R] :- M is N - 1, mk-n-holes M R.

%%%%% HB Utils %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% API, compat between 8.10 and 8.11
pred add-abbrev i:id, i:int, i:term, i:global?, i:bool, o:abbreviation.
add-abbrev N NParams AbbrevT Global OnlyParse Abbrev :-
  if (coq.version _ 8 10 _)
     (std.unsafe-cast coq.notation.add-abbreviation F, F N NParams AbbrevT Global OnlyParse Abbrev)
     (std.unsafe-cast coq.notation.add-abbreviation G, G N NParams AbbrevT Global OnlyParse _ Abbrev). % 8.11 has a deprecation flag

% runs P in a context where Coq #[attributes] are parsed
pred with-attributes i:prop.
with-attributes P :-
  attributes A, parse-attributes A [att "verbose" bool] Opts, !,
  Opts => P.

pred if-verbose i:prop.
if-verbose P :- get-option "verbose" tt, !, P.
if-verbose _.

% TODO: Should this only be used for gref that are factories? (and check in the first/second branch so?)
% Should we make this an HO predicate, eg "located->gref S L is-factory? GR"
pred located->gref i:string, i:list located, o:gref.
located->gref _ [loc-gref GR|_] GR.
located->gref _ [loc-abbreviation Abbrev|_] GR :- phant-abbrev GR _ Abbrev, !.
located->gref S [loc-abbreviation _|_] _ :- coq.error S "is an abbreviation out of the control of HB".
located->gref S [loc-modpath _|_] _ :- coq.error S "should be a factory, but is a module".
located->gref S [loc-modtypath _|_] _ :- coq.error S "should be a factory, but is a module type".
located->gref S [] _ :- coq.error "Could not locate name" S.

% TODO: generalize/rename when we support parameters
pred argument->gref i:argument, o:gref.
argument->gref (str S) GR :- located->gref S {coq.locate-all S} GR.
argument->gref X _ :- coq.error "Argument" X "is expected to be a string".

pred argument->term i:argument, o:term.
argument->term (str S) (global GR) :- !, argument->gref (str S) GR.
argument->term (trm T) T :- !, std.assert-ok! (coq.typecheck T _) "not well typed term".
argument->term X _ :- coq.error "Argument" X " is expected to be a term or a string".

% Type to share code between HB.mixin and HB.factory (that supports alias factories)
kind asset type.
type asset-mixin asset.
type asset-factory asset.

kind asset-decl type.
type asset-parameter  id -> term -> (term -> asset-decl) -> asset-decl.
type asset-record     id -> term -> id -> record-decl    -> asset-decl.
type asset-alias      id -> term                         -> asset-decl.

pred name-of-asset-decl i:asset-decl, o:string.
name-of-asset-decl (asset-parameter _ _ R) X :-
  pi x\ name-of-asset-decl (R x) X.
name-of-asset-decl (asset-record X _ _ _) X.
name-of-asset-decl (asset-alias X _) X.

pred argument->asset i:argument, o:asset-decl.
argument->asset (indt-decl (parameter Name Ty I)) (asset-parameter "T" Ty A) :- % TODO, take the name
  @pi-decl Name Ty a\
    argument->asset (indt-decl (I a)) (A a).
argument->asset (indt-decl (record Rid Ty Kid F)) (asset-record Rid Ty Kid F) :- !.
argument->asset (const-decl Id (some (fun _ _ Bo)) (some (prod Name Src Ty))) (asset-parameter "T" Src A) :- !,
  @pi-decl Name Src a\
    argument->asset (const-decl Id (some (Bo a)) (some (Ty a))) (A a).
argument->asset (const-decl Id (some Bo) (some Ty)) (asset-alias Id Bo) :- !,
  std.assert! (var Ty) "Factories aliases should not be given a type".
argument->asset X _ :- coq.error "Unsupported asset:" X.

pred builder->string i:builder, o:string.
builder->string (builder _ _ B) S :- coq.term->string B S.

pred nice-gref->string i:gref, o:string.
nice-gref->string X S :- coq.term->string (global X) S.

pred target-gref i:term, o:gref.
target-gref T GR :- whd1 T T1, !, target-gref T1 GR.
target-gref (prod N Src Tgt) GR :- !, @pi-decl N Src x\ target-gref (Tgt x) GR.
target-gref End GR :- term->gref End GR.

% Sometimes section variables are unused, hence the lambda may not be there
pred subst-fun-opt i:term, i:term, o:term.
subst-fun-opt T (fun _ _ _ as F) O :- !, subst-fun [T] F O.
subst-fun-opt T (let _ _ _ _ as F) O :- !, subst-fun [T] F O.
subst-fun-opt _ X X.

pred append-phant-unify i:phant-term, o:phant-term.
append-phant-unify (phant-term LP T) (phant-term LPU T) :-
  std.append LP [unify-arg] LPU.

pred copy-fields i:record-decl, o:record-decl.
copy-fields end-record end-record.
copy-fields (field C N T R) (field C N T1 R1) :-
  copy T T1,
  pi x\ copy x x => copy-fields (R x) (R1 x).

pred gref->modname i:mixinname, o:id.
gref->modname GR ModName :-
  coq.gref->path GR Path,
  if (std.rev Path [_,ModName|_]) true (coq.error "No enclosing module for " GR).

pred term->modname i:structure, o:id.
term->modname T ModName :- gref->modname {term->gref T} ModName.

%%%%%%%%% HB database %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Specialize coq.elpi.accumulate to "hiearchy.db"
pred acc i:scope, i:clause.
acc S CL :- coq.elpi.accumulate S "hb.db" CL.

pred from_mixin i:prop, o:mixinname.
from_mixin (from _ X _) X.

pred mixin-src_mixin i:prop, o:mixinname.
mixin-src_mixin (mixin-src _ M _) M.

pred extract-builder i:prop, o:builder.
extract-builder (builder-decl B) B.

pred leq-builder i:builder, i:builder.
leq-builder (builder N _ _) (builder M _ _) :- N =< M.

% [factory-alias->gref X GR] when X is already a factory X = GR
% however, when X is a phantom abbreviated gref, we find the underlying
% factory gref GR associated to it.
pred factory-alias->gref i:gref, o:gref.
factory-alias->gref PhGR GR :- phant-abbrev GR PhGR _, !.
factory-alias->gref GR GR :- phant-abbrev GR _ _, !.

pred sub-class? i:class, i:class.
sub-class? (class _ _ ML1) (class _ _ ML2) :-
  std.forall ML2 (m2\ std.exists ML1 (m1\ m1 = m2)).

% [factory-provides F ML] computes the mixins ML generated by F
pred factory-provides i:factoryname, o:list mixinname.
factory-provides FactoryAlias ML :- std.do! [
  factory-alias->gref FactoryAlias Factory,
  std.findall (from Factory T_ F_) All,
  std.map All from_mixin ML,
].

% [factories-provide FL ML] computes the mixins ML generated by all F in FL
pred factories-provide i:list factoryname, o:list mixinname.
factories-provide GRFS ML :- std.do! [
  std.map GRFS factory-provides MLUnsortedL,
  std.flatten MLUnsortedL MLUnsorted,
  toposort-mixins MLUnsorted ML,
].

% Mixins can be topologically sorted according to their dependencies
pred toposort-mixins.mk-mixin-edge i:prop, o:list (pair mixinname mixinname).
toposort-mixins.mk-mixin-edge (factory-requires M Deps) L :-
  std.map Deps (d\r\ r = pr d M) L.
pred toposort-mixins i:list mixinname, o:list mixinname.
toposort-mixins In Out :- std.do! [
  std.findall (factory-requires M_ Deps_) AllMixins,
  std.flatten {std.map AllMixins toposort-mixins.mk-mixin-edge} ES,
  toposort ES In Out,
].

% Classes can be topologically sorted according to the subclass relation
pred toposort-classes.mk-class-edge i:prop, o:pair class class.
toposort-classes.mk-class-edge (sub-class C1 C2) (pr C2 C1).
pred toposort-classes i:list class, o:list class.
toposort-classes In Out :- std.do! [
  std.findall (sub-class C1_ C2_) SubClasses,
  std.map SubClasses toposort-classes.mk-class-edge ES,
  toposort ES In Out,
].

pred findall-classes o:list class.
findall-classes CLSorted :- std.do! [
  std.findall (class-def C_) All,
  std.map All (x\r\ x = class-def r) CL,
  toposort-classes CL CLSorted
].

pred findall-builders o:list builder.
findall-builders LFIL :-
  std.map {std.findall (builder-decl B_)} extract-builder LFILunsorted,
  bubblesort LFILunsorted leq-builder LFIL.

% [distinct-pairs-below C AllSuper C1 C2] finds C1 and C2 in
% AllSuper (all super classes of C) such that C1 != C2
% and for which there is no join C3.
% If there exists a join C3 of C1 and C2 then C is a subclass
% of C3 (otherwise C should have been declared before C3)
%
%        / --- /-- C1
%    C -- no C3    !=
%        \ --- \-- C2
%
% [findall-newjoins C AllSuper] finds all C1 and C2 such that C is a (new) join for
% them
pred distinct-pairs-below i:class, i:list class, o:class, o:class.
distinct-pairs-below CurrentClass AllSuper C1 C2 :-
  std.mem AllSuper C1, std.mem AllSuper C2,
  % no cut until here, since we don't know which C1 and C2 to pick
  std.do! [
    cmp_term C1 C2 lt,
    C1 = class C1n _ _,
    C2 = class C2n _ _ ,
    not(sub-class? C1 C2),
    not(sub-class? C2 C1),
    if (join C1n C2n C3n)
       (assert-building-bottom-up CurrentClass C3n, fail) % a join, not a valid pair
       true, % no join, valid pair
  ].

pred assert-building-bottom-up i:class, i:classname.
assert-building-bottom-up CurrentClass C3n :-
  class-def (class C3n X Y),
  if (not (sub-class? CurrentClass (class C3n X Y)))
     (coq.error "You must declare" CurrentClass "before" C3n)
     true.

pred distinct-pairs_pair i:prop, o:pair class class.
distinct-pairs_pair (distinct-pairs-below _ _ X Y) (pr X Y).

pred findall-newjoins i:class, i:list class, o:list (pair class class).
findall-newjoins CurrentClass AllSuper TodoJoins :-
  std.findall (distinct-pairs-below CurrentClass AllSuper C1_ C2_) JoinOf,
  std.map JoinOf distinct-pairs_pair TodoJoins.

%%%%% Coq Database %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% [get-structure-coercion S1 S2 F] finds the coecion F from the structure S1 to S2
pred get-structure-coercion i:structure, i:structure, o:term.
get-structure-coercion (global S) (global T) (global F) :-
  coq.coercion.db-for (grefclass S) (grefclass T) L,
  if (L = [pr F 0]) true (coq.error "No one step coercion from" S "to" T).

pred get-structure-sort-projection i:structure, o:term.
get-structure-sort-projection (global (indt S)) (global (const P)) :-
  coq.CS.canonical-projections S L,
  if (L = [some P, _]) true (coq.error "No canonical sort projection for" S).

pred get-structure-class-projection i:structure, o:term.
get-structure-class-projection (global (indt S)) (global (const P)) :-
  coq.CS.canonical-projections S L,
  if (L = [_, some P]) true (coq.error "No canonical class projection for" S).

pred get-structure-constructor i:structure, o:term.
get-structure-constructor (global (indt S)) (global (indc K)) :-
  if (coq.env.indt S _ 0 0 _ [K] _) true (coq.error "Not a packed structure" S).

pred get-class-constructor i:classname, o:term.
get-class-constructor (indt S) (global (indc K)) :-
  if (coq.env.indt S _ 1 1 _ [K] _) true (coq.error "Not a class" S).

%% finding for locally defined structures
pred get-cs-structure i:cs-instance, o:term.
get-cs-structure (cs-instance _ _ (global Inst)) Struct :- std.do! [
  coq.env.typeof Inst InstTy,
  safe-dest-app InstTy Struct _
].

pred has-cs-instance i:gref, i:cs-instance.
has-cs-instance GTy (cs-instance _ (cs-gref GTy) _).

pred get-local-structures i:term, o:list term.
get-local-structures TyTrm StructL :- std.do! [
  std.filter {coq.CS.db} (has-cs-instance {term->gref TyTrm}) DBGTyL,
  std.map DBGTyL get-cs-structure StructL,
].

pred local-cs? i:term, i:term.
local-cs? TyTerm Struct :-
  get-local-structures TyTerm StructL,
  std.mem! StructL Struct.

pred get-canonical-mixins-of i:term, i:structure, o:list prop.
get-canonical-mixins-of T S MSL :- std.do! [
  get-structure-sort-projection S Sort,
  coq.unify-eq T (app [Sort, ST]),
  coq.unify-eq ST (app [_, _, C]),
  C = app [_, _ | MIL],
  std.map MIL (mixin-srcs T) MSLL,
  std.flatten MSLL MSL
].

pred under-canonical-mixins-of.do! i:term, i:list prop.
under-canonical-mixins-of.do! T P :-
  get-local-structures T CS,
  std.map CS (get-canonical-mixins-of T) MSLL,
  std.flatten MSLL MSL,
  MSL => std.do! P.

%%%%% mterm %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% A mterm is always of the form [mterm ML F], which is a pair of
% a list of mixins ML that should be substituted in F and a term F
kind mterm type.
type mterm list mixinname -> term -> mterm.

% Notations /Ã  la/ *pack* are always of the shape
% [Notation N x_0 .. x_n := C x_0 .. _ _ id .. x_i .. _ id _ _ id]
% with a variable number of [_] between each [id], and where
% - [x_i] is given by the user
% - [_]   correspond to arguments that are left implicit,
% - [id]  trigger unification as described in
% /Canonical Structures for the working Coq user/ by Mahboubi and Tassi
%
% phant-arg encode these three kind of arguments
% - [x_i] is encoded using [real-arg x_i]
% - [_]              using [implicit-arg]
% - [id]             using [unify-arg]
kind phant-arg type.
type real-arg name -> phant-arg.
type implicit-arg phant-arg.
type unify-arg phant-arg.

% phant-term is a pair of a list of argument kinds together with a term
kind phant-term type.
type phant-term list phant-arg -> term -> phant-term.

% [builder->term T Src Tgt MF] provides a term which is
% a function to transform Src into Tgt under the right mixin-src.
pred builder->term i:term, i:factoryname, i:mixinname, o:term.
builder->term T Src Tgt FT :- !, std.do! [
  from Src Tgt F, factory-requires Src ML, mterm->term T (mterm ML F) FT].

% [instantiate-mixin T F M_i TFX] where mixin-for T M_i X_i states that
% if    F  ~  fun xs (m_0 : M_0 T) .. (m_n : M_n T ..) ys
%            => F xs m_0 .. m_{i-1} m_i m_{i+1} .. m_n ys
% then TFX := fun xs m_0 .. m_{i-1}     m_{i+1} .. m_n ys
%            => F xs m_0 .. m_{i-1} X_i m_{i+1} .. m_n ys
% thus instanciating an abstraction on mixin M_i with X_i
pred instantiate-mixin i:term, i:mixinname, i:term, o:term.
instantiate-mixin T M (fun _ Tm F) R :-
  safe-dest-app Tm (global TmGR) _,
  factory-alias->gref TmGR M, !,
  mixin-for T M X, !,
  R = F X.
instantiate-mixin T M (fun N Ty F) (fun N Ty FX) :- !,
  pi m\ instantiate-mixin T M (F m) (FX m).
instantiate-mixin _ _ F F.

% [mterm->term T MF TFX] assumes that MF is a mterm
% (mterm ML F) and perform the substitution as above
% for every mixin-for entry out of the list ML = [M_0, .., M_n].
pred mterm->term i:term, i:mterm, o:term.
mterm->term T (mterm ML F) SFX :- std.do! [
  std.assert-ok! (coq.typecheck F Ty) "mterm->term: F illtyped",
  mk-eta (-1) Ty F EtaF,
  subst-fun [T] EtaF FT,
  std.fold ML FT (instantiate-mixin T) SFX
].

% [mgref->term T GR X] computes the dependencies of GR in mixins,
% (through factory-requires if it exist, otherwise gr-deps)
% and instanciates all of them through mixin-src, and fails if it cannot.
pred mgref->term i:term, i:gref, o:term.
mgref->term T GR X :- factory-requires GR ML, !, std.do! [
  mterm->term T (mterm ML (global GR)) X
].
mgref->term T GR X :- !, std.do! [
  std.assert! (gr-deps GR ML) "BUG: gr-deps should never fail",
  mterm->term T (mterm ML (global GR)) X
].


% [mixin-srcs T X MSL] states that MSL is a list of [mixin-src T m X]
% where m ranges all the mixins that the factory Src can provide,
% where Src is the type of X.
pred mixin-srcs i:term, i:term, o:list prop.
mixin-srcs T X MSL :- std.do! [
  std.assert-ok! (coq.typecheck X XTy) "mixin-src: X illtyped",
  if (not (safe-dest-app XTy (global _) _))
     (coq.error "Term:\n" {coq.term->string X}
                "\nhas type:\n" {coq.term->string XTy}
                "\nwhich is not a record")
     true,
  term->gref XTy Src,
  factory-alias->gref Src Factory,
  factory-provides Factory ML,
  % TODO: skip mixins for which there is already a source.
  std.map ML (m\r\ r = mixin-src T m X) MSL
].

pred under-mixin-src-from-factory.then i:term, i:term, i:(term -> prop), o:term.
under-mixin-src-from-factory.then TheType TheFactory P X :-
  mixin-srcs TheType TheFactory ML,
  ML => P X.

pred under-mixin-src-from-factory.do! i:term, i:term, i:list prop.
under-mixin-src-from-factory.do! TheType TheFactory P :-
  mixin-srcs TheType TheFactory ML,
  ML => std.do! P.

pred under-mixin-src-from-factories.do! i:term, i:list term, i:list prop.
under-mixin-src-from-factories.do! TheType Factories P :-
  std.map Factories (mixin-srcs TheType) MLL,
  std.flatten MLL ML,
  ML => std.do! P.

% [mixin-for T M X] states that X has type [M T ...]
% it is reconstructed from two databases [mixin-src] and [from]
pred mixin-for o:term, o:mixinname, o:term.
mixin-for T M MI :- mixin-src T M Tm, !, std.do! [
  std.assert-ok! (coq.typecheck Tm Ty) "mixin-for: Tm illtyped",
  term->gref Ty Src,
  factory-alias->gref Src Factory,
  if (M = Factory) (MI = Tm) (
      builder->term T Factory M F,
      subst-fun [Tm] F MI
  )
].

% ----------- Finding and instantiating mixin arguments -------------------

% [ty-deps Ty ML] states that ML is the list of
% mixins which the type Ty rely on, i.e.
% Ty = forall (m_0 : M_0 T) ... (m_n : M_n T ..), _ and ML = [M_0, .., M_n]
pred ty-deps i:term, o:list mixinname.
ty-deps (prod N S R) ML' :- !,
  @pi-decl N S x\
    ty-deps (R x) ML,
    safe-dest-app S HD _,
    if (HD = global GR, factory-alias->gref GR F, from  _ F _, !)
      (ML' = [F|ML]) (ML' = ML).
ty-deps Ty ML :- whd1 Ty Ty1, !, ty-deps Ty1 ML.
ty-deps _Ty [].

% [term-deps T ML] states that ML is the list of
% mixins which the term T rely on, i.e. T has type
% forall (m_0 : M_0 T) ... (m_n : M_n T ..), _ and ML = [M_0, .., M_n]
pred term-deps i:term, o:list mixinname.
term-deps T ML :-
  std.assert-ok! (coq.typecheck T Ty) "term-deps: T illtyped",
  ty-deps Ty ML.

% shorthand for gref.
pred gr-deps i:gref, o:list mixinname.
gr-deps GR ML :- term-deps (global GR) ML.

% [find-max-classes Mixins Classes] states that Classes is a list of classes
%   which contain all the mixins in Mixins.
% Although it is not strictly necessary, but desirable for debugging,
% we use a heuristic that tries to minimize the number
% of classes by assuming Mixins are reversed topologically sorted.
pred find-max-classes i:list mixinname, o:list classname.
find-max-classes [] [].
find-max-classes [M|Mixins] [C|Classes] :-
  mixin-first-class M C,
  std.do! [
    class-def (class C _ ML),
    std.filter Mixins (x\ not (std.mem! ML x)) Mixins',
    find-max-classes Mixins' Classes
  ].
find-max-classes [M|_] _ :- coq.error "cannot find a class containing mixin" M.

% [mk-mixin-fun.then T ML Pred F] states that F has type
% fun (m_0 : M_0 T) .. (m_n : M_n T m_i0 .. m_ik) => Body m_0 .. m_n
% where ML = [M_0, .., M_n]
% and Body is such that [..,mixin-src T M_i m_i,..] => Pred Body
pred mk-mixin-fun.then i:term, i:list gref, i:(term -> prop), o:term.
mk-mixin-fun.then _T [] Pred Body :- !, Pred Body.
mk-mixin-fun.then T [M|ML] Pred (fun `m` MTy FLG) :- std.do! [
  mgref->term T M MTy,
  @pi-decl `m` MTy m\ mixin-src T M m => mk-mixin-fun.then T ML Pred (FLG m)
].

% A *pack* notation can be easiliy produced from a phant-term using
% [mk-phant-abbrev N PT C], which states that C is a new constant
% which name is phant_N, and which produces a simple notation
% with name N using the data of the phant-term PT to reconstruct a notation
% [Notation N x0 .. xn := C x0 _ _ id .. xi .. _ id _ _ id]
% as described above.
pred mk-phant-abbrev.term i:int, i:term, i:list phant-arg, o:int, o:term.
mk-phant-abbrev.term K F [] K F.
mk-phant-abbrev.term K F [real-arg N|AL] K'' (fun N _ AbbrevFx) :- !,
  pi x\ mk-phant-abbrev.term K {mk-app F [x]} AL K' (AbbrevFx x),
  K'' is K' + 1.
mk-phant-abbrev.term K F [implicit-arg|AL] K' FAbbrev :- !,
  mk-phant-abbrev.term K {mk-app F [_]} AL K' FAbbrev.
mk-phant-abbrev.term K F [unify-arg|AL] K' FAbbrev :- !,
  mk-phant-abbrev.term K {mk-app F [{{lib:@hb.id _ _}}]} AL K' FAbbrev.

pred mk-phant-abbrev i:string, i:phant-term, o:constant, o:abbreviation.
mk-phant-abbrev N (phant-term AL T) C Abbrev :- std.do! [
  NC is "phant_" ^ N,
  std.assert-ok! (coq.typecheck T _TTy) "mk-phant-abbrev: T illtyped",
  coq.env.add-const NC T _ ff ff C,
  mk-phant-abbrev.term 0 (global (const C)) AL NParams AbbrevT,
  add-abbrev N NParams AbbrevT tt tt Abbrev,
].

% [acc-phant-abbrev Str GR Acc] makes a phantom abbreviation for F
pred acc-phant-abbrev i:string, i:gref, o:list prop.
acc-phant-abbrev _Str GR [] :- factory-alias->gref GR _, !.
acc-phant-abbrev Str GR [phant-abbrev GR (const PhC) Abbrev] :- !, std.do! [
  mk-phant-mixins (global GR) PhGR,
  mk-phant-abbrev Str PhGR PhC Abbrev
].

% [mk-phant-unify X1 X2 PF PUF] states that PUF is a phant-term that
% is starts with unifing X1 and X2 and then outputs PF.
pred mk-phant-unify i:term, i:term, i:phant-term, o:phant-term.
mk-phant-unify X1 X2 (phant-term AL F) (phant-term [unify-arg|AL] UF) :-
  UF = {{fun u : lib:hb.unify lp:X1 lp:X2 lib:hb.none => lp:F}}.

% [mk-phant-implicit N Ty PF PUF] states that PUF is a phant-term
% which quantifies [PF x] over [x : Ty] (with name N)
pred mk-phant-implicit i:name, i:term, i:(term -> phant-term), o:phant-term.
mk-phant-implicit N Ty PF (phant-term [implicit-arg|AL] (fun N Ty F)) :- !,
  pi t\ PF t = phant-term AL (F t).

% [mk-phant-struct T SI PF PSF] states that PSF is a phant-term
% which postulate a structure [s : SI] such that [T = sort s]
% and then outputs [PF s]
pred mk-phant-struct i:term, i:term, i:(term -> phant-term), o:phant-term.
mk-phant-struct T SI PF (phant-term [implicit-arg, unify-arg|AL] UF) :-
  get-structure-sort-projection SI Sort,
  pi s\ PF s = phant-term AL (F s),
  UF = {{fun (s : lp:SI) (u : lib:hb.unify lp:T (lp:Sort s)
    (lib:hb.some (lib:hb.pair "is not canonically a"%string lp:SI)))
      => lp:(F s)}}.

% [mk-phant-struct T CN PF PCF] states that PSF is a phant-term
% which postulate a structure [s : SI] such that [T = sort s]
% and a class [c : CN T] such that [s = CK T c] and then outputs [PF c]
pred mk-phant-class i:term, i:classname, i:(term -> phant-term), o:phant-term.
mk-phant-class T CN PF PSF :-
    class-def (class CN SI _CML), get-structure-constructor SI SK,
    PSF = {mk-phant-struct T SI s\
            {mk-phant-implicit `c` (app [global CN, T]) c\
              {mk-phant-unify s (app [SK, T, c]) (PF c)} } }.

% [mk-phant-mixins F PF] states that if F = fun T m_0 .. m_n => _
% then PF = phant-term
%   [real-arg T, implicit-arg, unify-arg, implicit-arg, unify-arg,
%                implicit-arg, .., implicit-arg, unify-arg, ...,
%                implicit-arg, unify-arg, implicit-arg, unify-arg,
%                implicit-arg, .., implicit-arg, unify-arg]
%   {{fun T => [find s_0 | T ~ s_0] [find c_0 | s_0 ~ SK T c_0]
%              [find m_0_0, .., m_0_n0 | c_0 ~ CK m_0_0 .. m_0_n0] ...
%              [find s_k | T ~ s_k] [find c_k | s_k ~ SK T c_k]
%              [find m_k_0, .., m_k_nk | c_k ~ CK m_k_0 .. m_k_nk]
%                F T m_i0_j0 .. m_il_jl}}
pred mk-phant-mixins.class-mixins i:term, i:classname, i:term,
  i:list mixinname, i:phant-term, o:phant-term.
mk-phant-mixins.class-mixins T CN C [] PF UPF :- !, std.do![
    get-class-constructor CN K, class-def (class CN _ CML),
    mterm->term T (mterm CML K) KCML,
    mk-phant-unify C KCML PF UPF].
mk-phant-mixins.class-mixins T CN C [M|ML] (phant-term AL FMML) LamPFmmL :- !,
    mgref->term T M MTy,
    (@pi-decl `m` MTy m\ mixin-src T M m => sigma FmML\
      instantiate-mixin T M FMML FmML,
      mk-phant-mixins.class-mixins T CN C ML (phant-term AL FmML) (PFmmL m)),
    mk-phant-implicit `m` MTy PFmmL LamPFmmL.

pred mk-phant-mixins.class i:term, i:classname, i:phant-term, o:phant-term.
mk-phant-mixins.class T CN PF SCF :- !,
    class-def (class CN _SI CML),
    SCF = {mk-phant-class T CN c\ {mk-phant-mixins.class-mixins T CN c CML PF} }.

pred mk-phant-mixins i:term, o:phant-term.
mk-phant-mixins F (phant-term [real-arg T|AL] (fun T _ CFML)) :- std.do! [
  std.assert-ok! (coq.typecheck F FTy) "mk-phant-mixins: F illtyped",
  ty-deps FTy ML,
  mk-eta (-1) FTy F EtaF,
%  toposort-mixins ML MLSorted,
  ML = MLSorted, % Assumes we give them already sorted in dep order.
  std.rev MLSorted MLSortedRev,
  find-max-classes MLSortedRev CNL,
  (@pi-decl T {{Type}} t\ sigma FML PML\
    std.fold CNL (phant-term [] {subst-fun [t] EtaF}) (mk-phant-mixins.class t)
      (phant-term AL (CFML t)))
].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              Synthesis                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Given a type T, a list of class definition in topological order (from least dep to most)
% it consumes the list all the classes for which all the dependencies
% (mixins) were postulated so far (skips the rest) and declares a local
% constant inhabiting the corresponding structure and declares it canonical.
pred declare-instances i:term, i:list class.
declare-instances T [class Class Struct ML|Rest] :-
  get-class-constructor Class KC,
  mterm->term T (mterm ML KC) KCApp, % we can build it
  not (local-cs? T Struct), % not already built
  !,
  term->gref T TGR,
  coq.gref->id TGR TID,
  Name is TID ^ "_is_a_" ^ {term->modname Struct},

  if-verbose (coq.say "HB: declare canonical instance" Name),

  get-structure-constructor Struct KS,
  S = app[KS, T, KCApp],
  std.assert-ok! (coq.typecheck S STy) "declare-instances: S illtyped",

  coq.env.add-const Name S STy ff ff CS, % Bug coq/coq#11155, could be a Let
  coq.CS.declare-instance (const CS), % Bug coq/coq#11155, should be local
  declare-instances T Rest.
declare-instances T [_|Rest] :- declare-instances T Rest.
declare-instances _ [].

% [main-factory-requires Str GR FL CL]
% computes the list of mixins ML provided by FL,
% creates a clause in CL stating that GR requires ML (factory-requires ..), and
% creates an abbreviation for GR names Str and creates a phant-abbrev clause in CL.
pred main-factory-requires i:string, i:gref, i:list factoryname, o:list prop.
main-factory-requires Str GR GRFS [FactoryRequires|Aliases] :- !, std.do! [
  factories-provide GRFS ML,
  FactoryRequires = factory-requires GR ML,
  acc-phant-abbrev Str GR Aliases
].

pred main-mixin-requires i:string, i:gref, i:list factoryname, o:list prop.
main-mixin-requires Str GR GRFS [From|PO] :- !, std.do! [
  main-factory-requires Str GR GRFS PO,
  % register factory
  PO => std.do! [
    coq.env.typeof GR (prod T TTy _),
    @pi-decl T TTy t\ mk-mixin-fun.then t {factory-requires GR} (body\ sigma MTy\
        mgref->term t GR MTy,
        body = fun `x` MTy x\x) (IDBody t)],
  From = from GR GR (fun T TTy IDBody),
].

% Given a type T, a fresh number N, and a mixin M it postulates
% a variable "mN" inhabiting M applied to T and
% all its dependencies, previously postulated and associated
% to the corresponding mixin using mixin-for
pred postulate-mixin i:term, i:mixinname, i:list prop, o:list prop.
postulate-mixin T M MSL [mixin-src T M (global (const C))|MSL] :- MSL => std.do! [
  Name is "mixin_" ^ {gref->modname M},

  if-verbose (coq.say "HB: postulate" Name "on" {coq.term->string T}),

  mgref->term T M Ty,
  std.assert-ok! (coq.typecheck Ty _) "postulate-mixin: Ty illtyped",
  coq.env.add-const Name _ Ty tt tt C % no body, local -> a variable
].

% Postulates a context with all the mixins provided by the factories
pred main-declare-context i:term, i:list factoryname, o:list prop.
main-declare-context T GRFS MSL :-  std.do! [
  factories-provide GRFS ML,
  std.fold ML [] (postulate-mixin T) MSL,
  MSL => declare-instances T {findall-classes},
  std.forall MSL (ms\ acc current (clause _ _ ms)),
].

% [factory-comp TheType SrcFactory MB MiddleFactory TgtMixin B1] synthesizes
%   B1 = MB o B
% where B is the builder from MiddleFactory to TgtMixin and
% MB is a builder from SrcFactory to MiddleFactory
pred factory-comp i:term, i:factoryname, i:mterm, i:factoryname, i:mixinname, o:term.
factory-comp TheType SrcFactory MB MiddleFactory TgtMixin MBoB :-
  mgref->term TheType SrcFactory Src,
  MBoB = {{
    fun src : lp:Src => lp:{{
      {under-mixin-src-from-factory.then TheType {{src}}
        (factory-comp-body TheType {{src}} MB MiddleFactory TgtMixin)} }}
  }}.

pred factory-comp-body i:term, i:term, i:mterm, i:factoryname, i:mixinname, o:term.
factory-comp-body TheType TheFactory MB MiddleFactory TgtMixin MBoB :- std.do! [
  mterm->term TheType MB MB1,
  subst-fun-opt TheFactory MB1 MB2,
  builder->term TheType MiddleFactory TgtMixin B,
  subst-fun [MB2] B MBoB
].

% [declare-builder ML Src F Mid Tgt FromI FromO]
% declares a builder by composing F and G.
pred declare-builder
  i:gref, i:list mixinname, i:term, i:term, i:gref, i:gref, i:list prop, o:list prop.
declare-builder SrcFactory SrcFactoryRequires B BTy MiddleFactory TgtMixin FromI [NewFrom|FromI] :- !, FromI => std.do! [
  std.assert! (BTy = prod _ TTy _) "declare-builder: B is not a function",

  MB = mterm SrcFactoryRequires B, % a B that we can fulfill with the context

  GoF = {{
    fun t : lp:TTy => lp:{{ % a fun for the type
      {mk-mixin-fun.then {{t}} SrcFactoryRequires
        (factory-comp {{t}} SrcFactory MB MiddleFactory TgtMixin)} }}
  }},

  std.assert-ok! (coq.typecheck GoF _GoFTy) "declare-builder: GoF illtyped",
  Name is {gref->modname SrcFactory} ^ "_to_" ^ {gref->modname TgtMixin} ^ {term_to_string {new_int}},
  coq.env.add-const Name GoF _GoFTy ff ff GoFC,
  NewFrom = from SrcFactory TgtMixin (global (const GoFC)),
].

% [main-declare-builder (builder _ F B) From MoreFrom] Given B of type FB, it
% generates all the builders for mixins in FB from F via components of B.
% From holds the (from F Mi Bi) predicates during folding.
pred main-declare-builder i:builder, i:list prop, o:list prop.
main-declare-builder (builder _ SrcFactory B) FromClauses MoreFromClauses :- !, std.do! [
  FromClauses => std.do! [
    std.assert-ok! (coq.typecheck B BTy) "main-declare-builder: B illtyped",
    factory-alias->gref {target-gref BTy} MiddleFactory,
    factory-requires SrcFactory SrcFactoryRequires,
    factory-provides MiddleFactory AllTgtMixins,
    std.filter AllTgtMixins (t\ not (std.mem! SrcFactoryRequires t)) TgtMixins,
  ],
  if-verbose (coq.say "HB: declare builders from" {nice-gref->string SrcFactory}
                      "to" {std.map TgtMixins nice-gref->string}),
  std.fold TgtMixins FromClauses (declare-builder SrcFactory SrcFactoryRequires B BTy MiddleFactory) MoreFromClauses,
].

% [export Module] exports a Module now adds it to the collection of
% modules to export in the end
pred to-export o:modpath.
pred export i:modpath.
export Module :- !,
  coq.env.export-module Module,
  acc current (clause _ _ (to-export Module)).

pred mk-mixin-fun i:term, i:list mixinname, i:term, o:term.
mk-mixin-fun T ML X MLX :- mk-mixin-fun.then T ML (body\ body = X) MLX.

pred clean-op-ty i:list prop, i:term, i:term, i:term, o:term.
clean-op-ty [] _ _ T1 T2 :- copy T1 T2.
clean-op-ty [exported-op Po C|Ops] SortPTheStructure TheStructure T1 T2 :-
  gr-deps (const Po) ML,
  mk-mixin-fun SortPTheStructure ML (app [global (const C), TheStructure]) EtaC,
  (pi L T R H S\
    copy (app [global (const Po), T|L]) R :- hd-beta EtaC L H S, unwind H S R) =>
    clean-op-ty Ops SortPTheStructure TheStructure T1 T2.

% given an operation (a mixin projection) we generate a constant projection the
% same operation out of the package structure (out of the class field of the
% structure). We also provide all the other mixin dependencies (other misins)
% of the package structure.
pred exported-op o:constant, o:constant. % memory
pred export-1-operation i:term, i:term, i:term, i:option constant, i:list prop, o:list prop.
export-1-operation _ _ _ none EX EX :- !. % not a projection, no operation
export-1-operation Struct Psort Pclass (some Poperation) EXI EXO :- !, std.do! [
  coq.gref->id (const Poperation) Name,
  (@pi-decl `s` Struct s\ sigma Carrier Class MSL DirtyTy Copies\ std.do! [
      Carrier = app[Psort, s],
      Class = app[Pclass, s],
      under-mixin-src-from-factory.do! Carrier Class [
        mgref->term Carrier (const Poperation) (Body s)
      ],
      std.assert-ok! (coq.typecheck (Body s) DirtyTy) "export-1-operation: Body illtyped",
      clean-op-ty EXI Carrier s DirtyTy (BodyTy s)]
  ),
  T = fun `x` Struct Body,
  Ty = prod `x` Struct BodyTy,

  if-verbose (coq.say "HB: export operation" Name),

  coq.env.add-const Name T Ty ff ff C,
  coq.arguments.set-implicit (const C) [[maximal]] tt,
  EXO = [exported-op Poperation C|EXI]
].

% Given a list of mixins, it exports all operations in there
pred export-operations.aux i:term, i:term, i:term, i:list mixinname.
export-operations.aux _ _ _ [].
export-operations.aux Struct ProjSort ProjClass [indt M|ML] :- !, std.do! [
  coq.CS.canonical-projections M Poperations,
  std.fold Poperations [] (export-1-operation Struct ProjSort ProjClass) _,
  export-operations.aux Struct ProjSort ProjClass ML
].
export-operations.aux Struct ProjSort ProjClass [GR|ML] :-
  coq.say GR "is not a record: skipping operations factory this mixin",
  export-operations.aux Struct ProjSort ProjClass ML.

pred export-operations i:term, i:term, i:term, i:list mixinname, o:list mixinname.
export-operations Structure ProjSort ProjClass ML MLToExport :-
  std.filter ML (m\not(mixin-first-class m _)) MLToExport,
  export-operations.aux Structure ProjSort ProjClass MLToExport.

% [declare-coercion P1 P2 C1 C2] declares a structure and a class coercion
% from C1 to C2 given P1 P2 the two projections from the structure of C1
pred declare-coercion i:term, i:term, i:class, i:class.
declare-coercion SortProjection ClassProjection
    (class FC StructureF _ as FCDef) (class TC StructureT TML as TCDef) :- std.do! [

  acc current (clause _ _ (sub-class FCDef TCDef)),

  term->modname StructureF ModNameF,
  term->modname StructureT ModNameT,
  CName is ModNameF ^ "_class_to_" ^ ModNameT ^ "_class",
  SName is ModNameF ^ "_to_" ^ ModNameT,

  std.map TML (from FC) FC2TML,
  get-class-constructor TC KC,
  Class = global FC,
  (pi T c\ sigma Mixes\
    std.map FC2TML (p\r\ r = app[p, T, c]) Mixes,
    ClassCoercion T c = app[KC, T | Mixes]),
  CoeBody = {{ fun (T : Type) (c : lp:Class T) => lp:(ClassCoercion T c) }},
  std.assert-ok! (coq.typecheck CoeBody Ty) "declare-coercion: CoeBody illtyped",

  if-verbose (coq.say "HB: declare coercion hint" CName),

  coq.env.add-const CName CoeBody Ty ff ff C,
  coq.coercion.declare (coercion (const C) 1 FC (grefclass TC)) tt,

  get-structure-constructor StructureT Pack,
  Coercion = global (const C),
  SCoeBody = {{ fun s : lp:StructureF =>
     let T : Type := lp:SortProjection s in
     lp:Pack T (lp:Coercion T (lp:ClassProjection s)) }},
  std.assert-ok! (coq.typecheck SCoeBody STy) "declare-coercion: SCoeBody illtyped",

  if-verbose (coq.say "HB: declare unification hint" SName),

  coq.env.add-const SName SCoeBody STy ff ff SC,
  coq.coercion.declare (coercion (const SC) 0 {term->gref StructureF} (grefclass {term->gref StructureT})) tt,
  coq.CS.declare-instance (const SC), % TODO: API in Elpi, take a @constant instead of gref
].

pred declare-join i:class, i:pair class class, o:prop.
declare-join (class C3 S3 _) (pr (class C1 S1 _) (class C2 S2 _)) (join C1 C2 C3) :-
  Name is {term->modname S1} ^ "_to_" ^ {term->modname S2},

  get-structure-coercion S3 S2 S3_to_S2,
  get-structure-coercion S3 S1 S3_to_S1,
  get-structure-sort-projection S1 S1_sort,
  get-structure-class-projection S2 S2_class,
  get-structure-constructor S2 S2_Pack,

  JoinBody = {{ fun s : lp:S3 =>
                   lp:S2_Pack (lp:S1_sort (lp:S3_to_S1 s))
                              (lp:S2_class (lp:S3_to_S2 s)) }},

  std.assert-ok! (coq.typecheck JoinBody Ty) "declare-join: JoinBody illtyped",

  if-verbose (coq.say "HB: declare unification hint" Name),

  coq.env.add-const Name JoinBody Ty ff ff J,
  coq.CS.declare-instance (const J).

% TODO: this works under the invariant: we never have two classes that
% contain exactly the same mixins. hb.structure should enforce this
% and eventually just alias the existing one rather than failing.
% TODO: hb.structure should check we are not inserting the class
% in the middle of existing ones. Possible fix: always declare all intermediate
% possibilities but without proper names (requires the previous TODO about
% aliasing already existing stuff).
pred declare-unification-hints i:term, i:term, i:class, o:list prop.
declare-unification-hints SortProj ClassProj CurrentClass NewJoins :- std.do! [
  findall-classes All,

  std.filter All (sub-class? CurrentClass) AllSuper,
  std.forall AllSuper (declare-coercion SortProj ClassProj CurrentClass),

  findall-newjoins CurrentClass AllSuper TodoJoins,

  std.map TodoJoins (declare-join CurrentClass) NewJoins
].

% For each mixin we declare a field and apply the mixin to its dependencies
% (that are previously declared fields recorded via field-for-mixin)
pred synthesize-fields i:term, i:list mixinname,o:record-decl.
synthesize-fields _T []     end-record.
synthesize-fields T  [M|ML] (field _ Name MTy Fields) :- std.do! [
  Name is {gref->modname M} ^ "_mixin",
  mgref->term T M MTy,
  @pi-decl `m` MTy m\ mixin-src T M m => synthesize-fields T ML (Fields m)
].

% Builds the axioms record and the factories from this class to each mixin
pred declare-class i:list mixinname, o:factoryname, o:list prop.
declare-class ML (indt ClassName) Factories :- std.do! [

  if-verbose (coq.say "HB: declare axioms record"),

  (@pi-decl `T` {{Type}} t\ synthesize-fields t ML (RDecl t)),
  ClassDeclaration =
    (parameter `T` {{ Type }} t\
      record "axioms" {{ Type }} "Class" (RDecl t)),
  std.assert-ok! (coq.typecheck-indt-decl ClassDeclaration) "declare-class: illtyped",
  coq.env.add-indt ClassDeclaration ClassName,
  coq.CS.canonical-projections ClassName Projs,
  std.map2 ML Projs (m\ p\ r\ sigma P\
    p = some P,
    r = from (indt ClassName) m (global (const P))) Factories
].

% Builds the package record
pred declare-structure i:factoryname, o:term, o:term, o:term.
declare-structure ClassName Structure SortProjection ClassProjection :- std.do! [

  if-verbose (coq.say "HB: declare type record"),

  StructureDeclaration =
    record "type" {{ Type }} "Pack" (
      field _ "sort" {{ Type }} s\
      field _ "class" (app [global ClassName, s]) _\ % on Coq 8.11 we should replace _ with [canonical ff]
    end-record),
  std.assert-ok! (coq.typecheck-indt-decl StructureDeclaration) "declare-structure: illtyped",
  coq.env.add-indt StructureDeclaration StructureName,

  coq.CS.canonical-projections StructureName [some SortP, some ClassP],
  Structure = global (indt StructureName),
  SortProjection = global (const SortP),
  ClassProjection = global (const ClassP),
].

% Declares "sort" as a coercion Structurename >-> Sortclass
pred declare-sort-coercion i:term, i:term.
declare-sort-coercion (global StructureName) (global Proj) :-

  if-verbose (coq.say "HB: declare sort coercion"),

  coq.coercion.declare (coercion Proj 0 StructureName sortclass) tt.

pred if-class-already-exists-error i:Name, i:list class, i:list mixinname.
if-class-already-exists-error _ [] _.
if-class-already-exists-error N [class _ S ML1|CS] ML2 :-
  if (list-eq-set ML1 ML2)
     (coq.error "Structure" {coq.term->string S} "contains the same mixins of" N)
     (if-class-already-exists-error N CS ML2).

pred main-declare-structure i:string, i:list gref, i:bool.
main-declare-structure Module GRFS ClosureCheck :- std.do! [
  factories-provide GRFS  PML,

  std.map GRFS factory-requires RML,
  std.flatten [PML|RML] UnsortedML,
  toposort-mixins UnsortedML ML,

  if (ClosureCheck = tt, not({std.length PML} = {std.length ML}))
     (coq.warn "pulling in dependencies:" {std.map {list-diff ML PML} nice-gref->string}
               "\nPlease list them or end the declaration with '....'")
     true,

  if-class-already-exists-error Module {findall-classes} ML,

  % TODO: check we never define the superclass of an exising class

  if-verbose (coq.say "HB: start module" Module),

  coq.env.begin-module Module none,

  declare-class ML  ClassName Factories,
  ClassRequires = factory-requires (ClassName) [],
  ClassAlias = (factory-alias->gref ClassName ClassName),

  declare-structure ClassName  Structure SortProjection ClassProjection,
  CurrentClass = (class ClassName Structure ML),

  if-verbose (coq.say "HB: start module Exports"),

  coq.env.begin-module "Exports" none,
  declare-sort-coercion Structure SortProjection,
  ClassAlias => ClassRequires => Factories =>
    export-operations Structure SortProjection ClassProjection ML MLToExport,
  ClassAlias => ClassRequires => Factories =>
    declare-unification-hints SortProjection ClassProjection CurrentClass NewJoins,
  % Register in Elpi's DB the new structure
  % NOT TODO: All these acc are correctly locaed in an Export Module
  std.forall MLToExport (m\
     acc current (clause _ _ (mixin-first-class m ClassName))),
  std.forall Factories (f\ acc current (clause _ _ f)),
  acc current (clause _ _ ClassRequires),
  acc current (clause _ _ ClassAlias),
  std.forall NewJoins (j\ acc current (clause _ _ j)),
  acc current (clause _ _ (class-def CurrentClass)),
  coq.env.end-module Exports,

  coq.env.end-module _,

  if-verbose (coq.say "HB: end modules; export" Exports),

  export Exports,
].

pred main-begin-declare i:string, i:string, i:list gref, i:declaration.
main-begin-declare Module TName GRFS Decl :- std.do! [

  if-verbose (coq.say "HB: start module and section" Module),

  coq.env.begin-module Module none,
  coq.env.begin-section Module,

  if-verbose (coq.say "HB: postulate type" TName),

  coq.univ.new [] U,
  Ty = sort (typ U),
  coq.env.add-const TName _ Ty tt tt T, % no body, local -> a variable
  main-declare-context (global (const T)) GRFS _,
  acc current (clause _ _ (current-decl Decl))
].

pred main-end-declare-builders.
main-end-declare-builders :- std.do! [
  current-decl (builders-for-factory GR),

  coq.env.end-section,

  findall-builders LFIL,

  if-verbose (coq.say "HB: declare builders from factory" {nice-gref->string GR}
              "using" {std.map LFIL builder->string}),

  std.fold LFIL [] main-declare-builder Clauses,

  if (Clauses = [])
     (coq.error "No builders to declare, did you forget HB.instance?")
     true,

  % TODO: Do we need this module?
  gref->modname GR M,
  Name is M ^ "_Exports",
  coq.env.begin-module Name none,
  (std.forall Clauses c\ acc current (clause _ _ c)),

  coq.env.end-module Exports,
  coq.env.end-module _,
  export Exports,
].

pred main-declare-canonical-instances i:term, i:list term.
main-declare-canonical-instances T FIL :- std.do! [
  if (current-decl (builders-for-factory FGR))
     (std.forall FIL (f\ sigma N\
        new_int N, acc current (clause _ _ (builder-decl (builder N FGR f)))))
     true,
  under-mixin-src-from-factories.do! T FIL [
  under-canonical-mixins-of.do! T [
    declare-instances T {findall-classes}
  ]],
].

pred main-begin-declare-builders i:context-decl.
main-begin-declare-builders (context-item ID T none Factories) :- std.do! [
  Name is "Builders_" ^ {term_to_string {new_int}}, % TODO
  coq.env.begin-module Name none,
  coq.env.begin-section Name,
  std.assert! (T = sort (typ _)) "The first context item must be a type variable",
  coq.univ.new [] U,
  Ty = sort (typ U),
  coq.env.add-const ID _ Ty tt tt C, % no body, local -> a variable
  TheType = global (const C),
  builders-postulate-factories (Factories TheType) TheType [],
].

pred postulate-factory-abbrev i:term, i:id, i:factoryname, o:term.
postulate-factory-abbrev TheType Name Falias TheFactory :- std.do! [
  factory-alias->gref Falias F,
  phant-abbrev F _ Fabv,
  coq.notation.abbreviation Fabv [TheType] Package,
  Msg is "Unable to declare factory " ^ Name,
  std.assert-ok! (coq.typecheck-ty Package _) Msg,
  coq.env.add-const Name _ Package tt tt C,
  TheFactory = global (const C),
].

% Only record fields can be exported as operations.
pred define-factory-operations i:term, i:term, i:gref.
define-factory-operations TheType TheFactory (indt I) :- !,
  coq.env.indt I _ NParams _ _ _ _,
  NHoles is NParams - 1,
  coq.CS.canonical-projections I PL,
  std.forall PL (define-factory-operation TheType TheFactory NHoles).
define-factory-operations _ _ _.

pred define-factory-operation i:term, i:term, i:int, i:option constant.
define-factory-operation _ _ _ none.
define-factory-operation TheType TheFactory NHoles (some P) :-
  mk-n-holes NHoles Holes,
  std.append Holes [TheFactory] Holes_Factory,
  T = app[global (const P), TheType|Holes_Factory],
  std.assert-ok! (coq.typecheck T _) "Illtyped applied factory operation",
  coq.gref->id (const P) Name,
  coq.gref->id {term->gref TheFactory} F,
  OpName is Name ^ "_" ^ F,
  add-abbrev OpName 0 T ff ff _.

pred builders-postulate-factories i:context-decl, i:term, i:list mixinname.
builders-postulate-factories (context-item ID T none _\ context-end) TheType GRML :- std.do! [
  std.assert! (T = app[global GR, TheType|_]) "a factory must be a name applied to the type variable",
  factory-alias->gref GR GRF,
  factory-requires GRF FML,
  std.append GRML FML GRFML,
  main-declare-context TheType GRFML _,
  postulate-factory-abbrev TheType ID GR TheFactory,
  define-factory-operations TheType TheFactory GRF,
  acc current (clause _ _ (current-decl (builders-for-factory GRF))),
].
builders-postulate-factories (context-item ID _ (some _) _) _ _ :-
  coq.error "factories cannot be given a body:" ID.
builders-postulate-factories (context-item ID1 _ none _\ context-item ID2 _ _ _) _ _ :-
  coq.error "only one factory is supported, got at least two" ID1 "and" ID2.

pred main-declare-asset i:asset-decl, i:asset.
main-declare-asset (asset-parameter Name T Rest as R) D :- std.do! [
  name-of-asset-decl R Module,

  if-verbose (coq.say "HB: start module and section" Module),

  coq.env.begin-module Module none,
  coq.env.begin-section Module,

  if-verbose (coq.say "HB: postulate type" Name),

  std.assert! (T = sort (typ _)) "The first record parameter must be a type",
  coq.univ.new [] U,
  Ty = sort (typ U),
  coq.env.add-const Name _ Ty tt tt C, % no body, local -> a variable
  TheType = global (const C),
  collect-asset-parameters (Rest TheType) [] TheType D
].

pred collect-asset-parameters i:asset-decl, i:list factoryname, i:term, i:asset.
collect-asset-parameters (asset-parameter _ T Rest) GRFS TheType D :- std.do! [
  std.assert! (T = app[global F, TheType]) "Factory not applied to the type variable",
  std.assert! (pi x y\ Rest x = Rest y) "Factories cannot be mentioned in the mixin",
  Dummy = sort prop,
  collect-asset-parameters (Rest Dummy) [F|GRFS] TheType D
].

collect-asset-parameters (asset-alias _ Ty) GRFS TheType D :-
  std.assert! (D = asset-factory) "Mixins cannot be aliases",
  % refresh implicit arguments, since many binders are now gone
  (pi X Y\ copy X Y :- var X, !) => copy Ty Ty1,
  declare-factory-alias Ty1 GRFS TheType.

collect-asset-parameters (asset-record _ Sort _ Fields) GRFS TheType D :-
  % refresh implicit arguments, since many binders are now gone
  (pi X Y\ copy X Y :- var X, !) => (copy-fields Fields Fields0, copy Sort Sort1),
  declare-mixin-or-factory Sort1 Fields0 GRFS TheType D.

pred declare-factory-alias i:term, i:list factoryname, i:term.
declare-factory-alias Ty1 GRFS TheType :- std.do! [

  main-declare-context TheType {std.rev GRFS} Hyps,

  std.assert-ok! (coq.typecheck-ty Ty1 _) "Illtyped alias factory",
  coq.env.add-const "axioms_" Ty1 _ ff ff C,

  std.assert! (safe-dest-app Ty1 (global PhF) _Args) "Argument must be a factory",
  std.assert! (factory-alias->gref PhF F) "BUG: Factory alias declaration missing",
  std.assert! (factory-constructor F FK) "BUG: Factory constructor missing",

  Hyps => mgref->term TheType FK MFK,
  std.assert-ok! (coq.typecheck MFK MFKTy) "BUG: typecking of former factory constructor failed",
  (pi Args\ copy (app [global F|Args]) (global (const C))) => copy MFKTy MFKTyC,
  coq.env.add-const "Axioms_" MFK MFKTyC ff ff CK,
  GRK = const CK,

  coq.env.end-section,

  mk-phant-mixins (global GRK) PhGRK0,
  if (mixin-first-class F _) (PhGRK = PhGRK0) (append-phant-unify PhGRK0 PhGRK),
  mk-phant-abbrev "Axioms" PhGRK _ _,

  std.map Hyps mixin-src_mixin ML,
  main-factory-requires "axioms" (const C) ML Props,

  if-verbose (coq.say "HB: start module Exports"),

  coq.env.begin-module "Exports" none,
  (std.forall Props c\ acc current (clause _ _ c)),
  % std.map {gr-deps GRK} (_\ r\ r = maximal) Implicits,
  % coq.arguments.set-implicit GRK [[maximal|Implicits]] tt,
  acc current (clause _ _ (factory-constructor (const C) GRK)),
  coq.env.end-module Exports,
  coq.env.end-module _Module,

  if-verbose (coq.say "HB: end modules and sections; export" Exports),

  export Exports,
].

pred declare-mixin-or-factory i:term, i:record-decl, i:list factoryname, i:term, i:asset.
declare-mixin-or-factory Sort1 Fields0 GRFS TheType D :- std.do! [
  if (D = asset-mixin) (Fields1 = Fields0)
     (Fields1 = (field _ "_" {{ lib:hb.unify lp:TheType lp:TheType lib:hb.none }} _\ Fields0)),
  main-declare-context TheType {std.rev GRFS} Hyps,

  if-verbose (coq.say "HB: declare record axioms_"),

  Kname = "Axioms_",
  RDecl = record "axioms_" Sort1 Kname Fields1,
  std.assert-ok! (coq.typecheck-indt-decl RDecl) "record declaration illtyped",
  coq.env.add-indt RDecl R,
  coq.env.end-section,
  coq.env.indt R tt _ _ _ [K] _,
  GRK = indc K,

  % TODO: should this be in the Exports module?
  if-verbose (coq.say "HB: declare notation axioms"),

  mk-phant-mixins (global GRK) PhGRK0,

  if-verbose (coq.say "HB: declare notation Axioms"),

  if (D = asset-mixin) (PhGRK = PhGRK0) (append-phant-unify PhGRK0 PhGRK),
  mk-phant-abbrev "Axioms" PhGRK _ _,

  std.map Hyps mixin-src_mixin ML,
  if (D = asset-mixin)
     (main-mixin-requires "axioms" (indt R) ML Props)
     (main-factory-requires "axioms" (indt R) ML Props),

  if-verbose (coq.say "HB: start module Exports"),

  coq.env.begin-module "Exports" none,
  (std.forall Props c\ acc current (clause _ _ c)),
  std.map {gr-deps GRK} (_\ r\ r = maximal) Implicits,
  coq.arguments.set-implicit GRK [[maximal|Implicits]] tt,
  acc current (clause _ _ (factory-constructor (indt R) GRK)),
  coq.env.end-module Exports,
  coq.env.end-module _Module,

  if-verbose (coq.say "HB: end modules and sections; export" Exports),

  export Exports,
].

