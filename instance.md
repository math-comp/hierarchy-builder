<b> Saturating instances on new structure declaration </b>

When a new structure S_new is created, the instances of factories that the new structure implements are not recorded in the database, instead they are in the coq databse. We want to get the list of factories attached to S_new and create properly the instances that implements those factories with the new structure.

See the test file tests/instance_before_structure.v for an example

functions get-canonical-instances and get canonical-structures let us interact with the coq database 

```coq
1. has-mixin-instance CS-pattern mixinname inst.
2. mixin-src {{list lp:X}} {{hasmx}} {{i: eq I}} :- coq unification X eqType I (with X = sort I)
3. has-struct-instance CS-KEY class.
```

To create the list of booleans we need to have the section paramaters from the instance definition passed down through the clauses, so the information is saved in the database. 

- This list of booleans is created by sect-params-in-term which given a list of section parameters SP and a term T, returns a list of boolean corresponding to whether or not a parameter in SP appears in T.

- This information is crucial in creating the right clauses to saturate the right instances later.

We'll also need later to add parameters from user-created section by interrogating the coq database.


Hierarchy builder is supposed to find links within the hierarchy of structures and instances (joins betweens elements).


Let's say we have an instance I1 for the structure S1 verifying a mixin M1 and similarly I2, S2, and M2. 
If we were to introduce a structure S3 which needs a type verifying both M1 and M2 for a type T compatible with I1 and I2, an instance for S3 and T should be generated automatically, and not only upon encountering a new instance. 

So order matters greatly as a new structure wouldn't know about all the previously defined instances, until a new instace is created.

---

Saturating instances works on instances with parameters this way : 

1. When an instance is created by the user, some clauses of the form mixin-src are created for each mixin instance successfully created. 
    Such a clause has the form
    ```prolog
    mixin-src Ty, M, I.
    ```

    where I can be used to reconstruct an instance of M Ty.

    Those clauses were used to then infer new structures.
But we need more information kept in the database.
For each of those clauses, we now store instead a new clause `has-mixin-instance` generated by the translation predicate
`mixin-src->has-mixin-instance`. 

    The clauses `has-mixin-instance` still link some concrete instance with the mixins it satisfies but now instead of storing the type of the instance which is too restrictive, we store the canonical structure pattern which allows to be more generic.

    Now when such an instance is declared :
    ```coq
    HB.instance Definition I1 (X:t1) : mixin1 (list X) := ... .  
    ```
    a clause of this form is generated 
    ```coq
    has-mixin-instance (cs-gref (indt «list»)) (indt «mixin1.axioms_») (const «I1»)
    ```

2. When a structure S is declared, we want to try to populate it with types already encountered at step 1, which wasn't done before.

    To do so, at the end of a structure declaration, we call a function `saturate-instances`. 
    We need parametrised `mixin-src` clauses with conditions on parameters. For this we call `mk-src-map` which takes the `has-mixin-instance` and creates the right `mixin-src` clauses.

    Then for each type at the head of the clauses,  we try to declare new instances with the new clauses at our disposal with the function `declare-all-generic-type`.
        
        This function preprocesses the type with `enrich_type` which takes a term, and for each forall quantifiers in it, applies as many holes as necessary.

        Then the function `infer_1` is called which actually tries to create an instance on that enriched type. If it is succesful we need to close the term we got with elpi quantifiers and save the instance in the coq database with `save_1`.

    
        
    
